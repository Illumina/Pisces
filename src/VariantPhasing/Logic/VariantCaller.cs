using System;
using System.Collections.Generic;
using System.Linq;
using Pisces.IO.Sequencing;
using Pisces.Calculators;
using Pisces.Domain.Models.Alleles;
using Pisces.IO;
using Pisces.Processing.Utility;
using VariantPhasing.Interfaces;
using VariantPhasing.Utility;
using VariantPhasing.Models;

namespace VariantPhasing.Logic
{
    public class VariantCaller
    {
        private readonly VariantCallingParameters _callerParams;
        private readonly BamFilterParameters _bamParams;
        
        public VariantCaller(VariantCallingParameters callerParams, BamFilterParameters bamParams)
        {
            _bamParams = bamParams;
            _callerParams = callerParams;
        }

       
        public CalledAllele ReCallAsRef(CalledAllele usedVariant, int numRefCallsSuckedUpByOtherVariants)
        { 

                var newRef = PhasedVariantExtractor.Create(
                         usedVariant.Chromosome, usedVariant.Coordinate,
                          usedVariant.Reference.Substring(0, 1), ".",
                          Math.Max(0,usedVariant.ReferenceSupport - numRefCallsSuckedUpByOtherVariants), usedVariant.TotalCoverage, Pisces.Domain.Types.AlleleCategory.Reference,
                          _bamParams.MinimumBaseCallQuality, _callerParams.MaximumVariantQScore);


                CallCandidate(newRef, true);
                AddFilters(newRef, true);
            
            return newRef;
        }

        public void CallRefs(IVcfNeighborhood completedNbhd)
        {
            var suckedUpRefCalls = completedNbhd.UsedRefCountsLookup;
            Dictionary<int, CalledAllele> possibleRefs = new Dictionary<int, CalledAllele>();
            var variantsRecalledByMnvCaller = completedNbhd.GetOriginalVcfVariants();

            foreach (var allele in variantsRecalledByMnvCaller)
            {
                int suckedUpRefCallCount = 0;
                if (suckedUpRefCalls.ContainsKey(allele.Coordinate))
                    suckedUpRefCallCount = suckedUpRefCalls[allele.Coordinate];

                var newRef = ReCallAsRef(allele, suckedUpRefCallCount);

                if (!possibleRefs.ContainsKey(newRef.Coordinate))
                {
                    possibleRefs.Add(newRef.Coordinate, newRef);
                }
            }

            completedNbhd.CalledRefs = possibleRefs;
        }


        public void CallMNVs(IVcfNeighborhood completedNbhd)
        {
            var foundMNVs = new Dictionary<int, List<CalledAllele>>();
            foreach (var mnv in completedNbhd.CandidateVariants)
            {
                bool isReference = (mnv.Type == Pisces.Domain.Types.AlleleCategory.Reference);

                CallCandidate(mnv, isReference);

                AddFilters(mnv, isReference);

                if (!foundMNVs.ContainsKey(mnv.Coordinate))
                    foundMNVs.Add(mnv.Coordinate, new List<CalledAllele>());
        
                foundMNVs[mnv.Coordinate].Add(mnv);
            }

            completedNbhd.CalledVariants = foundMNVs;

        }

     

        private void AddFilters(CalledAllele mnv, bool isReference)
        {
            var newFilters = new List<Pisces.Domain.Types.FilterType>();

            if (mnv.VariantQscore < _callerParams.MinimumVariantQScoreFilter)
            {
                newFilters.Add(Pisces.Domain.Types.FilterType.LowVariantQscore);
            }

            if (mnv.Frequency < _callerParams.MinimumFrequencyFilter)
            {
                if (!isReference)
                    newFilters.Add(Pisces.Domain.Types.FilterType.LowVariantFrequency);
            }

            //what about the original filters? looks like we loose them... (if we allowed non-passing variaats into phasing)
            //NOTE:
            //This overwrites the original variant filters.  Since in practice, 
            //(A) we only ever run this is Passing Variants Only mode, so original variants used in phasing always have an empty filter list anyway, it doenst matter.
            //(B) the variants generated by scylla are basically new, so its not clear anymore if the old filters should be recycled. 
            //(C) the right TODO, if all orignal fitlers are desired, is force scylla through exactly the same set of fiters
            // (SB, RmxN, etc, that the original Pisces used... This is currently not implmented. 

            foreach (var filter in newFilters)
            {
                if (!mnv.Filters.Contains(filter))
                    mnv.Filters.Add(filter);
            }
        }

        private void CallCandidate(CalledAllele mnv, bool isReference)
        {

            mnv.NoiseLevelApplied = _bamParams.MinimumBaseCallQuality;

            //tjd
            //since any input variant passed filters, we assume it is not SB'ed.
            //Before the big Scylla refactor, we used to copy the SB number from the original variant at this index. but thats not really consistent with the new call.

            //gb
            //yes, we can assume that the component variants were not strand biased according to the thresholds used in the original Pisces run, but that doesn't mean that they're necessarily -100 

            //tjd:
            //Correct.  Alternatly, here are some other options:
            // A) We could leave the SB tag off the final var call, or set it to Nan,
            // but that could be a downstream parsing problem.
            // B) We could make some number up based the SB of the input variants 
            // (some max value to represent the worst case of the component variants in the nbdh...?) 
            // C) Implement a fully stranded phasing model.
            // IMO, if we put work into this, we should do C. This will probably be a feature request before too long anyway.
            //For the moment, nothing affects actually pass/Fail varcall decisions.

            mnv.StrandBiasResults.GATKBiasScore = -100;

            if (mnv.VariantQscore < _callerParams.MinimumVariantQScore)
            {

                if (isReference)
                    mnv.Genotype = Pisces.Domain.Types.Genotype.RefLikeNoCall;
                else
                    mnv.Genotype = Pisces.Domain.Types.Genotype.AltLikeNoCall;

                mnv.GenotypeQscore = 0;
            }

            if (mnv.Frequency < _callerParams.MinimumFrequency)
            {
                if (isReference)
                    mnv.Genotype = Pisces.Domain.Types.Genotype.RefLikeNoCall;
                else
                    mnv.Genotype = Pisces.Domain.Types.Genotype.AltLikeNoCall;

                mnv.VariantQscore = 0;
                mnv.GenotypeQscore = 0;
            }

            //as an alternative to setting them to nocalls, we could just omit them from gvcf.
        }

    }

}
